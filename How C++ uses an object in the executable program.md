### What are all the default member-functions created by compiler for a class?
- Suppose you have declared class like:
```
class Thing {};
```
- Compiler will probably synthesize this class as:
```
class Thing {
public:
    Thing();                        // default constructor
    Thing(const Thing&);            // copy c'tor
    Thing& operator=(const Thing&); // copy-assign
    ~Thing();                       // d'tor
    // C++11:
    Thing(Thing&&);                 // move c'tor
    Thing& operator=(Thing&&);      // move-assign
};
```
- So by default compiler will generate:
	1. default constructor
	2. copy constructor 
	3. copy-assign operator
	4. desstructor
	5. move constructor
	6. move-assign operator

Note: This stands true till C++ 14.
- All those are only generated by the compiler when they are needed. The compiler cannot create them, when they aren't used.

### How object used in executable function ?
-  Given the following function, where class X defines a copy constructor, virtual destructor, and virtual function foo():
```
X foobar()
{
	X xx;
	X *px = new X;

	// foo() is virtual function
	xx.foo();
	px->foo();
	
	delete px;
	return xx;
};

```
- Probable internal transformation would be:
```
void foobar( X &_result )
{
	// _result replaces local xx & constructor called
	_result.X::X();
	// expand X *px = new X;
	px = _new( sizeof( X ));
	if ( px != 0 )
		px->X::X();
	
	// expand xx.foo(): replaced xx with _result
	foo( &_result );
	// expand px->foo() using virtual mechanism
	( *px->_vtbl[ 2 ] )( px )
	
	// expand delete px;
	if ( px != 0 ) {
		( *px->_vtbl[ 1 ] )( px ); // destructor
		_delete( px );
	}
	// replace named return statement
	// no need to destroy local object xx
	return;
};
```
- This is how object oriented paradigm converted into procedure oriented paradigm.

### How & where constructor code transform/synthesize with inheritance & composition class ?

```
class Foo 
{ 
public: 
  Foo(){cout<<"Foo"<<endl;} 
  ~Foo(){cout<<"~Foo"<<endl;} 
};

class base 
{ 
public: 
  base(){cout<<"base"<<endl;}
  ~base(){cout<<"~base"<<endl;}
};

class Bar /* : public base */
{ 
  Foo foo; 
  char *str; 
public: 
  Bar()
  {
    cout<<"Bar"<<endl;
    str = 0;
  }
  ~Bar(){cout<<"~Bar"<<endl;}
};
```
- Compiler augmented `Bar` constructor would be look like:
```
Bar::Bar()
{
  foo.Foo::Foo(); // augmented compiler code
  
  cout<<"Bar"<<endl; // explicit user code
  str = 0; // explicit user code
}
```
- Same goes for, multiple class member objects requiring constructor initialization. The language specifies that the constructors would be invoked in the order of member declaration within the class. This is accomplished by the compiler.
- If object member does not define a default constructor, a non-trivial default constructor is synthesized by a compiler for respective classes.
- In the case of inheritance, constructor calling sequence is started from base(top-down) to derived manner. Constructor synthesis & augmentation remain same as above. So in above case if you derive `Bar` from `Base` then constructor calling sequence would be `Base` -> `Foo` -> `Bar`.

### How & where destructor code transform/synthesize with inheritance & composition class ?
- In case of destructor, calling sequence is exactly the reverse that of a constructor. Like in above case it would be `Bar` -> `Foo` -> `Base`. Synthesis & augmentation remain same as above.

### How & where virtual table code will be inserted?
- Virtual table code will be insereted by compiler before & after user written code in constructor & destructor that too on demand of user implementation.
- For the question "How virtual table code will be inserted?", my answer is this is purely compiler dependent. C++ standard only mandates behaviour. Although this would not be complex. It probably would look like:
```
this->_vptr[0] = type_info("class_name");
```
### Reference
- https://stackoverflow.com/questions/3734247/what-are-all-the-member-functions-created-by-compiler-for-a-class-does-that-hap
- Book: Inside C++ Object Model By Lippman
